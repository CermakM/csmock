#!/bin/sh
SELF="$0"

test -z "$TMPDIR" && TMPDIR="/tmp"

# rpm macros to use
RPMM="\
--define '_smp_mflags -ij5' \
--define '_without_testsuite 1' \
--define 'runselftest 0' \
--define 'with_docs 0' \
--define 'with_publican 0'"

# PATH set for cov-build/rpmbuild
ENV_PATH="\$PATH:/usr/kerberos/bin"

# other environment variables used for cov-build/rpmbuild
ENV_VARS="\
CC=gcc \
CXX=g++"

OPTS=x

usage(){
    echo "Usage: $SELF [-$OPTS] MOCK_PROFILE my-package.src.rpm"
    exit 1
}

# with the -x option, build the package without downstream patches
XPATCH=no

while getopts $OPTS opt; do
    case "$opt" in
        x)
            XPATCH=yes
            ;;

        *)
            usage
            ;;
    esac
done
shift $(($OPTIND - 1))

# the first operand is the mock profile to use
MOCK_PROFILE="$1"
export MOCK_PROFILE
MOCK_CFG="/etc/mock/$MOCK_PROFILE.cfg"
test -f "$MOCK_CFG" || usage

# the second operand is the SRPM to build/analyze
SRPM="$2"
test -f "$SRPM" || usage

die(){
    if test -n "$1"; then
        echo "$SELF: error: $1" >&2
    else
        echo "$SELF: generic error" >&2
    fi
    test -f "$STATUS" && echo 1 > "$STATUS"
    exit 1
}

# prepare $TMP directory
TMP="`mktemp -d $TMPDIR/cov-mockbuild.XXXXXX`"
test -d "$TMP" || die "mktemp failed"
STATUS="$TMP/status"
echo 0 > "$STATUS" || die "failed to write '$STATUS'"
export TMP STATUS

die_if_exists(){
    while test -n "$1"; do
        test -e "$1" && die "'$1' already exists"
        shift
    done
}

# avoid overwriting of .cov, .log, .out, or .err
BASE="`basename "$SRPM" .src.rpm`"
COV="`readlink -f "$BASE".cov`"
LOG="`readlink -f "$BASE".log`"
OUT="`readlink -f "$BASE".out`"
ERR="`readlink -f "$BASE".err`"
die_if_exists "$COV" "$LOG" "$OUT" "$ERR"
export COV LOG OUT ERR

# copy the SRPM to our temp
SRPM_DUP="$TMP/`basename "$SRPM"`"
die_if_exists "$SRPM_DUP"
cp -t "$TMP" -v "$SRPM" 2>&1 | tee --append "$LOG"
test -f "$SRPM_DUP" || die

# prepare a hack to get cov-build working with up2date g++
FIXUPS="$TMP/fixups.sh"
cat > "$FIXUPS" << EOF
#!/bin/sh

# symlink the gcc version we have outside the chroot
gccdir=/usr/lib/gcc/x86_64-redhat-linux
gccver="\`find \$gccdir -mindepth 1 -maxdepth 1 -type d | head -n1\`"
gccver=\`basename \$gccver\`
ln -s \$gccver /usr/lib/gcc/x86_64-redhat-linux/4.4.4
ln -s \$gccver /usr/lib/gcc/x86_64-redhat-linux/4.4.5

# patch xmlto if installed
if test -x /usr/bin/xmlto; then
    patch /usr/bin/xmlto << XXX
--- xmlto
+++ xmlto.coverity
@@ -23,6 +23,8 @@
 BASH=bash     # GNU bash, for running the format scripts
 GETOPT=getopt # a getopt that supports --longoptions
 
+unset XML_CATALOG_FILES
+
 version () {
   echo "xmlto version 0.0.18"
 }
XXX
fi

dd of=/tmp/type_traits.patch status=noxfer << XXX
--- type_traits
+++ type_traits.coverity
@@ -223,30 +223,6 @@
   template<typename>
     struct is_function
     : public false_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes...)>
-    : public true_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes......)>
-    : public true_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes...) const>
-    : public true_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes......) const>
-    : public true_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes...) volatile>
-    : public true_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes......) volatile>
-    : public true_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes...) const volatile>
-    : public true_type { };
-  template<typename _Res, typename... _ArgTypes>
-    struct is_function<_Res(_ArgTypes......) const volatile>
-    : public true_type { };

   // composite type traits [4.5.2].
   
XXX

# simplify C++ headers for Coverity in case of gcc-4.4.5 and gcc-4.6.0
if test -d /usr/include/c++/4.4.5; then
    PATCH_STRING_H=yes
    sed -i 's/^#ifndef __GXX_EXPERIMENTAL_CXX0X__$/#if 0/' \
        /usr/include/c++/4.4.5/c++0x_warning.h \
        || exit \$?
fi
if test -d /usr/include/c++/4.6.0; then
    PATCH_STRING_H=yes
    sed -i 's/^#ifndef __GXX_EXPERIMENTAL_CXX0X__$/#if 0/' \
        /usr/include/c++/4.6.0/bits/c++0x_warning.h \
        || exit \$?
fi

# this file is provided by libstdc++-devel, which is not installed by default
if test -f /usr/include/c++/4.4.5/tr1_impl/type_traits; then
    patch /usr/include/c++/4.4.5/tr1_impl/type_traits < /tmp/type_traits.patch
fi
if test -f /usr/include/c++/4.6.0/tr1_impl/type_traits; then
    patch /usr/include/c++/4.6.0/tr1_impl/type_traits < /tmp/type_traits.patch
fi

if test xyes = "x\$PATCH_STRING_H"; then
    sed -i 's/__GNUC_PREREQ (4, 4)$/0/' /usr/include/string.h \
        || exit \$?
fi
EOF

# prepare a dummy patcher
if test xyes = "x$XPATCH"; then
    PWRAP_DIR="$TMP/pwrap"
    mkdir "$PWRAP_DIR" || die

    if echo "$MOCK_PROFILE" | grep "rhel-5"; then
        # el5 rpm does not seem to use the %{__patch} macro for some reason
        ENV_PATH="$PWRAP_DIR:$ENV_PATH"
    fi

    PWRAP="$PWRAP_DIR/patch"
    cat > "$PWRAP" << EOF
#!/bin/sh

need_for_build(){
    while test -n "\$1"; do
        if test "x--suffix" = "x\$1"; then
            shift
            if test "x_RAWBUILD" = "x\$1"; then
                return 0
            fi
        fi

        shift
    done

    return 1
}

if need_for_build "\$@"; then
    echo "\$0: applying a patch annotated by _RAWBUILD" >&2
    /usr/bin/patch "\$@"
else
    echo "\$0: ignoring a patch not annotated by _RAWBUILD" >&2
    dd of=/dev/null status=noxfer 2>/dev/null
fi
EOF
    chmod 0755 "$PWRAP"
    RPMM="$RPMM --define '__patch $PWRAP' \
--define '_rawbuild -b _RAWBUILD' \
--define 'nopam 1' \
--define 'norunuser 1' \
--define 'noselinux 1' \
--define '_with_vanilla 1'"
fi

# prepare .tar of all the files we need inside mock chroot
TPL_BASE="stage1.tar"
TPL="$TMP/$TPL_BASE"
tar cf "$TPL" "$SRPM_DUP" $PWRAP                \
    "$FIXUPS"                                   \
    /etc/resolv.conf                            \
    /opt/coverity/VERSION.xml                   \
    /opt/coverity/config                        \
    /opt/coverity/dtd                           \
    /opt/coverity/bin/cov-*                     \
    /opt/coverity/bin/libcapture-*.so           \
    || die "failed to create $TPL"

# invoke mock with given parameters
mock_wrap(){
    printf ">>> %s starting mock %s\n"          \
        "`date`" "$*"                           \
        | tee --append "$LOG"                   \
        || die

    (mock -r "$MOCK_PROFILE" "$@" || die        \
        "\"mock $*\" exited with $?")           \
        2>&1 | tee --append "$LOG"              \
        || die
}

# NOTE: We can't use --installroot or --installdeps because the host RPM
# version is completely incompatible with the version inside mock chroot

# initialize mock chroot
mock_wrap --init
mock_wrap --copyin "$TPL" /tmp
rm -f "$TPL"

# prepare all we need to build the package
mock_wrap --chroot "tar -C / -xvf \"/tmp/$TPL_BASE\""

# we intentionally do not use 'mock --installdeps' because of --nogpgcheck
mock_wrap --install "xml-common"
mock_wrap --install "yum-utils"
mock_wrap -v --chroot "yum-builddep --nogpgcheck \"$SRPM_DUP\""

# TODO: branch by RHEL version
mock_wrap -v --chroot "sh -x $FIXUPS"

mock_wrap --chroot "rpm -Uvh --nodeps \"$SRPM_DUP\""

# run the build through cov-build
SPEC="`rpm -lpq "$SRPM_DUP" 2>/dev/null | grep '\.spec$'`"
#mock_wrap --chroot "/opt/coverity/bin/cov-configure --gcc"
mock_wrap -v --chroot "PATH=$ENV_PATH $ENV_VARS \
/opt/coverity/bin/cov-build --dir /builddir/cov \
rpmbuild -bc --nodeps /builddir/build/SPECS/$SPEC $RPMM"

# get the intermediate directory out of the chroot and store it to $COV
mock_wrap --chroot "chmod -R +r /builddir/cov"
mock_wrap --copyout /builddir/cov "$COV"
cat "$COV/build-log.txt" >> "$LOG" 2>&1

# ###########################################################################
# we do not need the chroot anymore
mock_wrap --clean

# run the analysis and store the summary to $OUT
printf ">>> %s starting analysis\n" "`date`" | tee --append "$LOG"
(cov-analyze --dir "$COV" --wait-for-license    \
    || die "cov-analyze failed") 2>&1           \
    | tee "$OUT"                                \
    | tee --append "$LOG"                       \
    || die

# store the list of defects to $ERR
printf ">>> %s reporting defects\n" "`date`" | tee --append "$LOG"
( (cov-format-errors --dir "$COV" --emacs-style \
    || die "cov-format-errors failed")          \
        | perl -i -p -e 's/([0-9]):\n/\1: /'    \
        | perl -i -p -e 's/^Error: /\nError: /' \
        > "$ERR") 2>&1                          \
    | tee --append "$LOG"                       \
    || die

EC="`head -n1 "$STATUS" | tr -d "\n"`"
rm -rf "$TMP"
echo "<<< $0 has finished, exit code is $EC" | tee --append "$LOG"
exit $EC
