#!/bin/bash

# Copyright (C) 2011 Red Hat, Inc.
#
# This file is part of csdiff.
#
# csdiff is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# csdiff is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with csdiff.  If not, see <http://www.gnu.org/licenses/>.

SELF="$0"
ARGS="$@"

set -o pipefail

export LC_ALL=C

test -z "$TMPDIR" && TMPDIR="/tmp"

# rpm macros to use
RPMM="\
--define '_smp_mflags -kj5' \
--define '_without_testsuite 1' \
--define 'cmake cmake' \
--define 'libguestfs_runtests 0' \
--define 'runselftest 0' \
--define 'with_docs 0' \
--define 'with_publican 0'"

# PATH set for cov-build/rpmbuild
ENV_PATH="\$PATH:/usr/kerberos/bin"

OPTS=d:fitx

usage(){
    cat << EOF
usage: $SELF [-$OPTS] MOCK_PROFILE my-package.src.rpm [COV_OPTS]

  -d  A space-separated list of manually added dependences needed for build.

  -f  Overwrite the file with results if it already exists.  By default, this
      would fail.

  -i  Keep Coverity intermediate directory for further processing.  By default,
      only build-log.txt is kept.

  -t  Do not compress the resulting tarball.  Used to save time in case it is
      going to be extracted right away.

  -x  Skip patches not annotated by %{?_rawbuild}.  That is, do a vanilla build.

  MOCK_PROFILE  Only name of the mock profile, without the path and without
                the .cfg suffix.

  COV_OPTS      Options passed to cov-analyze.
EOF
    exit 1
}

while getopts $OPTS opt; do
    case "$opt" in
        d)  EXTRA_DEPS="$OPTARG"
            ;;

        f)  OVERWRITE_RESULTS=yes
            ;;

        i)
            KEEP_COV=yes
            ;;

        t)  TAR_ONLY=yes
            ;;

        x)
            RAWBUILD=yes
            ;;

        *)
            usage
            ;;
    esac
done
shift $(($OPTIND - 1))

# the first operand is the mock profile to use
MOCK_PROFILE="$1"
MOCK_CFG="/etc/mock/$MOCK_PROFILE.cfg"
test -f "$MOCK_CFG" || usage

EC=
update_ec() {
    last_ec=$?
    if test 128 -le "$last_ec" -a "$last_ec" -lt 192; then
        echo "<<< $SELF: child signalled to die by $(($last_ec - 128))" >&2
        exit $last_ec
    fi

    echo "--- $SELF: exit code was: $last_ec" >&2
    test -n "$EC" || EC=$last_ec
}

die(){
    if test -n "$1"; then
        echo "$SELF: error: $1" >&2
    else
        echo "$SELF: generic error" >&2
    fi
    update_ec 1
    exit 1
}

# the second operand is the SRPM to build/analyze
SRPM="`readlink -f "$2"`"
test -n "$SRPM" || usage
test -r "$SRPM" || die "failed to open $SRPM"
rpm -pq "$SRPM" || die "failed to open an RPM package: $SRPM"
rpm -lpq "$SRPM" 2>/dev/null | grep '\.spec$' \
    || die "no specfile found in $SRPM"

BASE="`basename "$SRPM" .src.rpm`"
if test xyes = "x$TAR_ONLY"; then
    TGZ="$PWD/$BASE.tar"
else
    TGZ="$PWD/$BASE.tar.xz"
    TAR_OPTS=-J
fi

if test xyes = "x$OVERWRITE_RESULTS"; then
    rm -fv "$TGZ"
fi

test -e "$TGZ" && die "'$TGZ' already exists"

if test xyes = "x$RAWBUILD"; then
    RUN=run0
else
    RUN=run1
fi

cmd_wrap() {
    printf "\n>>> %s\t%s\n" "`date`" "$*" >&2
    "$@"
}

# prepare $TMP directory
TMP="`mktemp -d $TMPDIR/cov-mockbuild.XXXXXX`"
BASE_DIR="$TMP/$BASE/$RUN"
mkdir -p "$BASE_DIR" || die "mktemp failed"

# from now on, do the pack/cleanup on exit, no matter if we succeeded or not
trap "test -z \"\$EC\" || touch \"${BASE_DIR}.FAILED\"
    cmd_wrap tar $TAR_OPTS -cvf '$TGZ' -C '$TMP' '$BASE'
    echo --- $SELF: removing $TMP... 2>&1; rm -rf '$TMP'" EXIT

INI="$BASE_DIR/$BASE.ini"
COV="$BASE_DIR/$BASE.cov"
LOG="$BASE_DIR/$BASE.log"
OUT="$BASE_DIR/$BASE.out"
ERR="$BASE_DIR/$BASE.err"

self_ver() (
    rpm -q cov-mockbuild 2>&1
)

# extra options for cov-analyze
shift
shift
COV_OPTS="--wait-for-license $*"

echo
printf "[scan]
tool = cov-mockbuild
tool-version = %s
tool-args = %s
analyzer = coverity
analyzer-version = %s
analyzer-args = %s
host = %s
config = %s
started = %s\n" \
    "`self_ver`" "$ARGS" "`cov-analyze --ident`" "$COV_OPTS" "`hostname`" \
    "$MOCK_PROFILE" "`date '+%Y-%m-%d %H:%M:%S'`" \
    | tee "$INI"

# copy the SRPM to our temp
SRPM_BASE="`basename "$SRPM"`"
SRPM_DUP="$TMP/$SRPM_BASE"
cp -t "$TMP" "$SRPM" 2>&1 | tee --append "$LOG"
test -f "$SRPM_DUP" || die

# prepare a hack to get cov-build working with up2date g++
FIXUPS="$TMP/fixups.sh"
cat > "$FIXUPS" << EOF
#!/bin/sh

# patch xmlto if installed
if test -x /usr/bin/xmlto; then
    patch /usr/bin/xmlto << XXX
--- xmlto
+++ xmlto.coverity
@@ -23,6 +23,8 @@
 BASH=bash     # GNU bash, for running the format scripts
 GETOPT=getopt # a getopt that supports --longoptions
 
+unset XML_CATALOG_FILES
+
 version () {
   echo "xmlto version 0.0.18"
 }
XXX
fi

# patch gtkdoc-mkhtml if installed
if test -x /usr/bin/gtkdoc-mkhtml; then
    patch /usr/bin/gtkdoc-mkhtml << XXX
3a4,5
> unset XML_CATALOG_FILES
> 
XXX
fi

# patch asciidoc if installed
if test -x /usr/bin/a2x; then
    patch /usr/bin/a2x << XXX
--- a2x
+++ a2x.coverity
@@ -7,6 +7,8 @@
 # under the terms of the GNU General Public License (GPL).
 #
 
+unset XML_CATALOG_FILES
+
 VERSION=1.0.0
 BASENAME=\\\$(basename "\\\$0")
 REALNAME="\\\$0"
XXX
fi

# Coverity 5.4.1 does not support the 'deprecated' attribute taking an argument
if test -w /usr/include/glib-2.0/glib/gmacros.h; then
    patch /usr/include/glib-2.0/glib/gmacros.h << XXX
diff --git a/gmacros.h b/gmacros.h
--- a/gmacros.h
+++ b/gmacros.h
@@ -295,7 +295,7 @@
 #define G_DEPRECATED
 #endif
 
-#if    __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+#if 0
 #define G_DEPRECATED_FOR(f) __attribute__((deprecated("Use '" #f "' instead")))
 #elif defined(_MSC_FULL_VER) && (_MSC_FULL_VER > 140050320)
 #define G_DEPRECATED_FOR(f) __declspec(deprecated("is deprecated. Use '" #f "' instead"))
XXX
fi

# Coverity 5.4.1 does not support the 'deprecated' attribute taking an argument
if test -w /usr/include/nss3/pkcs11n.h; then
    patch /usr/include/nss3/pkcs11n.h << XXX
diff --git a/mock/pkcs11n.h b/mock/pkcs11n.h
--- a/mock/pkcs11n.h
+++ b/mock/pkcs11n.h
@@ -362,7 +362,7 @@
  *  cast the resulting value to the deprecated type in the #define, thus
  *  producting the warning when the #define is used.
  */
-#if (__GNUC__  == 4) && (__GNUC_MINOR__ < 5)
+#if 1
 /* The mac doesn't like the friendlier deprecate messages. I'm assuming this
  * is a gcc version issue rather than mac or ppc specific */
 typedef CK_TRUST __CKT_NSS_UNTRUSTED __attribute__((deprecated));
XXX
fi

# Coverity 5.4.1 does not support NSPR-style static assertions
if test -w /usr/include/nspr4/prtypes.h; then
    patch /usr/include/nspr4/prtypes.h << XXX
diff --git a/mock/prtypes.h b/mock/prtypes.h
--- a/mock/prtypes.h
+++ b/mock/prtypes.h
@@ -548,8 +548,8 @@
 ** The macro can be used only in places where an "extern" declaration is
 ** allowed.
 */
-#define PR_STATIC_ASSERT(condition) \\\\
-    extern void pr_static_assert(int arg[(condition) ? 1 : -1])
+#define PR_STATIC_ASSERT(condition)
+
 
 PR_END_EXTERN_C
 
XXX
fi
EOF

BASHRC="$TMP/bashrc"
BASHRC_TPL="/usr/share/covscan/bashrc"
if test -r "$BASHRC_TPL"; then
    cp "$BASHRC_TPL" "$BASHRC"
else
    touch "$BASHRC"
fi

# prepare a dummy patcher
if test xyes = "x$RAWBUILD"; then
    PWRAP_DIR="$TMP/pwrap"
    mkdir "$PWRAP_DIR" || die

    if echo "$MOCK_PROFILE" | grep "rhel-5"; then
        # el5 rpm does not seem to use the %{__patch} macro for some reason
        ENV_PATH="$PWRAP_DIR:$ENV_PATH"
    fi

    PWRAP="$PWRAP_DIR/patch"
    cat > "$PWRAP" << EOF
#!/bin/sh

need_for_build(){
    while test -n "\$1"; do
        if test "x--suffix" = "x\$1"; then
            shift
            if test "x_RAWBUILD" = "x\$1"; then
                return 0
            fi
        fi

        shift
    done

    return 1
}

if need_for_build "\$@"; then
    echo "\$0: applying a patch annotated by _RAWBUILD" >&2
    /usr/bin/patch "\$@"
else
    echo "\$0: ignoring a patch not annotated by _RAWBUILD" >&2
    dd of=/dev/null status=noxfer 2>/dev/null
fi
EOF
    chmod 0755 "$PWRAP"
    RPMM="$RPMM --define '__patch $PWRAP' \
--define '_rawbuild -b _RAWBUILD' \
--define 'nofips 1' \
--define 'nopam 1' \
--define 'norunuser 1' \
--define 'noselinux 1' \
--define '_with_vanilla 1'"
fi

# prepare .tar of all the files we need inside mock chroot
TPL_BASE="bootstrap.tar"
TPL="$TMP/$TPL_BASE"
{ printf "\n>>> %s\tcreating %s\n" "`date`" "$TPL" | tee --append "$LOG"; } >&2
tar -cP -f "$TPL" "$SRPM_DUP" $PWRAP "$FIXUPS" "$BASHRC" \
    /etc/resolv.conf                            \
    /opt/coverity/VERSION.xml                   \
    /opt/coverity/config                        \
    /opt/coverity/dtd                           \
    /opt/coverity/bin/cov-*                     \
    /opt/coverity/bin/libcapture-*.so           \
    || die "failed to create $TPL"

# invoke mock with given parameters
mock_wrap(){
    { cmd_wrap mock -r "$MOCK_PROFILE" "$@"; } 2>&1 \
        | tee --append "$LOG"
}

# initialize mock chroot
mock_wrap --init                || die "mock --init failed"
mock_wrap --copyin "$TPL" /tmp  || die "mock --copyin failed"
rm -f "$TPL"

# prepare all we need to build the package
mock_wrap --chroot "tar -C / -xf \"/tmp/$TPL_BASE\"" || die "bootstrap failed"
mock_wrap --install "xml-common" "yum-utils" || die "mock --install failed"

if test -n "$EXTRA_DEPS"; then
    # install all dependences manually specified by the user
    mock_wrap --install $EXTRA_DEPS || update_ec
fi

# yet another desperate attempt to install missing deps; without the following
# hack it was impossible to install lm_sensors-devel as a dependency
# of net-snmp-5.5-31.el6.src.rpm
eval mock_wrap -v --install "`rpm -pq "$SRPM_DUP" --requires | while read dep
    do printf " '%s'" "$dep"
done`"

# 'mock --installdeps' is not always sufficient, neither yum-builddep is
mock_wrap -v --installdeps "$SRPM_DUP"

# install the SRPM within the mock chroot
SPEC="`rpm -lpq "$SRPM_DUP" 2>/dev/null | grep '\.spec$'`"
mock_wrap --chroot "rpm -Uvh --nodeps \"$SRPM_DUP\"" \
    || die "failed to install SRPM"

# make the unpacked contents of the SRPM accessible (if the maintainer did not)
mock_wrap --chroot "chmod -R +r /builddir/build"

# rebuild the SRPM to avoid RPM incompatibilities when resolving deps
mock_wrap --chroot "rpmbuild -bs --nodeps /builddir/build/SPECS/$SPEC $RPMM"

# ensure the just built SRPM has the same name as the original one
mock_wrap --chroot "/bin/bash -c 'cd /builddir/build/SRPMS && \
eval mv -v *.src.rpm $SRPM_BASE || :'"

# 'mock --installdeps' is not always sufficient, neither yum-builddep is
mock_wrap --copyout "/builddir/build/SRPMS/$SRPM_BASE" "$SRPM_DUP"
mock_wrap -v --installdeps "$SRPM_DUP"
mock_wrap -v --chroot "yum-builddep --nogpgcheck \
/builddir/build/SRPMS/$SRPM_BASE"

# TODO: branch by RHEL version
mock_wrap -v --chroot "sh -x $FIXUPS"

# run the %prep phase as usually (without cov-build)
mock_wrap -v --chroot "/bin/su mockbuild -lc \". \"$BASHRC\"; PATH=$ENV_PATH \
rpmbuild -bp --nodeps /builddir/build/SPECS/$SPEC $RPMM\""  || update_ec

# run the %build phase through cov-build
mock_wrap -v --chroot "/bin/su mockbuild -lc \". \"$BASHRC\"; PATH=$ENV_PATH \
/opt/coverity/bin/cov-build --dir /builddir/cov rpmbuild -bc --nodeps \
--short-circuit /builddir/build/SPECS/$SPEC $RPMM\""        || update_ec

# get the intermediate directory out of the chroot and store it to $COV
mock_wrap --chroot "chmod -R +r /builddir/cov"              || update_ec
mock_wrap --copyout /builddir/cov "$COV"                    || update_ec

# ###########################################################################
# we do not need the chroot anymore
mock_wrap --clean                                           || update_ec

# run the analysis and store the summary to $OUT
{ cmd_wrap cov-analyze --dir "$COV" $COV_OPTS \
    | tee "$ERR"; } 2>&1 | tee --append "$LOG"              || update_ec

# get rid of those fancy progress markers
grep -v "^|" "$ERR" | grep -v "^\*" > "$OUT"

# store the list of defects to $ERR
{ cmd_wrap cov-format-errors --dir "$COV" --emacs-style \
    | perl -i -p -e 's/([0-9]):\n/\1: /'                \
    | perl -i -p -e 's/^Error: /\nError: /'             \
    | perl -i -p -e 's/^\/buildddir\/build\/BUILD//'    \
    > "$ERR"; } 2>&1 | tee --append "$LOG"                  || update_ec

printf "finished = %s\n" "`date '+%Y-%m-%d %H:%M:%S'`" >> "$INI"

if test xyes != "x$KEEP_COV"; then
    mv "$COV/build-log.txt" "$COV/.."
    rm -rf "$COV"
fi

printf "\n<<< %s has finished, exit code is %s\n" "$SELF" "${EC:=0}"  \
    | tee --append "$LOG"

exit $EC
