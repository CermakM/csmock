#!/usr/bin/env python

# Copyright (C) 2014 Red Hat, Inc.
#
# This file is part of csmock.
#
# csmock is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# csmock is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with csmock.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import codecs
import datetime
import os.path
import re
import shutil
import subprocess
import sys
import tempfile
import time

class ScanResults:
    def __init__(self, output):
        self.output = output
        self.use_xz = False
        self.use_tar = False
        self.dirname = os.path.basename(output)
        self.ec = 0

        m = re.match("^(.*)\\.xz$", self.dirname)
        if m is not None:
            self.use_xz = True
            self.dirname = m.group(1)

        m = re.match("^(.*)\\.tar$", self.dirname)
        if m is not None:
            self.use_tar = True
            self.dirname = m.group(1)

    def __enter__(self):
        self.tmpdir = tempfile.mkdtemp(prefix="csmock")
        self.resdir = "%s/%s" % (self.tmpdir, self.dirname)
        os.mkdir(self.resdir)
        tee = ["tee", "%s/scan.log" % self.resdir]
        self.log_pid = subprocess.Popen(tee, stdin=subprocess.PIPE)

        # the following hack is needed to support both Python 2 and 3
        codec = codecs.lookup('utf8')
        self.log_fd = codecs.StreamReaderWriter(self.log_pid.stdin,
                codec.streamreader,
                codec.streamwriter)

        return self

    def __exit__(self, type, value, bt):
        self.print_with_ts("csmock exit code: %d\n" % self.ec, prefix=">>> ")
        self.log_fd.close()
        if self.use_tar:
            tar_opts = "-c"
            if self.use_xz:
                tar_opts += "J"
            tar_cmd = "tar %s -f '%s' -C '%s' '%s'" % (tar_opts,
                    self.output, self.tmpdir, self.dirname)
            if os.system(tar_cmd) == 0:
                sys.stderr.write("Wrote: %s\n\n" % self.output)
                shutil.rmtree(self.tmpdir)
        else:
            os.system("mv -fvT '%s' '%s'" % (self.resdir, self.output))
        sys.exit(self.ec)

    def print_with_ts(self, msg, prefix="<<< "):
        ts = datetime.datetime.now().isoformat()
        self.log_fd.write("%s%s\t%s\n" % (prefix, ts, msg))

    def error(self, msg, ec=1, err_prefix=""):
        self.print_with_ts("%serror: %s\n" % (err_prefix, msg), prefix="!!! ")
        if (self.ec < ec):
            self.ec = ec

    def fatal_error(self, msg):
        self.error(msg, err_prefix="fatal ")
        sys.exit(1)

    def exec_cmd(self, cmd):
        self.print_with_ts(str(cmd))
        p = subprocess.Popen(cmd, stdout=self.log_fd, stderr=self.log_fd)
        rv = p.wait()
        self.log_fd.write("\n")
        return rv

    def get_cmd_output(self, cmd, input=None):
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=self.log_fd,
                shell=True)
        (out, _) = p.communicate()
        return (p.returncode, out)

class MockWrapper:
    def __init__(self, results, mock_profile):
        self.results = results
        self.mock_profile = mock_profile
        self.lock_file = "/tmp/.csmock-%s.lock" % mock_profile
        self.meta_lock_file = "/tmp/.csmock-%s.metalock" % mock_profile
        self.pid = os.getpid()

    def __enter__(self):
        cmd = "flock -w15 '%s' -c \"test ! -f '%s' && echo %d > '%s'\"" % (
                self.meta_lock_file, self.lock_file, self.pid, self.lock_file)
        while (os.system(cmd) != 0):
            f = open(self.lock_file)
            other_pid = ""
            if f is not None:
                other_pid = f.readline().rstrip()
                f.close()
            msg = "waiting till %s (PID %s) disappears..."
            self.results.print_with_ts(msg % (self.lock_file, other_pid))
            time.sleep(15)

        return self

    def __exit__(self, type, value, bt):
        cmd = "test -r '%s' && test %d = \"$(<%s)\" && rm -f '%s'" % (
                self.lock_file, self.pid, self.lock_file, self.lock_file)
        os.system(cmd)

    def exec_mock_cmd(self, args):
        cmd = ["mock", "-r", self.mock_profile] + args
        return self.results.exec_cmd(cmd)

# argparse._VersionAction would write to stderr, which breaks help2man
class VersionPrinter(argparse.Action):
    def __init__(self, option_strings, dest=None, default=None, help=None):
        super(VersionPrinter, self).__init__(option_strings=option_strings,
                dest=dest, default=default, nargs=0, help=help)
    def __call__(self, parser, namespace, values, option_string=None):
        print("@VERSION@")
        sys.exit(0)

def require_file(parser, name):
    """Print an error and exit unsuccessfully if 'name' is not a file"""
    if not os.path.isfile(name):
        parser.error("'%s' is not a file" % name)

def nvr_from_srpm(srpm):
    return re.sub('\.src\.rpm$', '', os.path.basename(srpm))

# initialize argument parser
parser = argparse.ArgumentParser()
parser.add_argument("SRPM",
        help="source RPM package to be scanned by static analyzers")

# TODO: register plug-ins

# define optional arguments
parser.add_argument("-r", "--root", dest="mock_profile", default="default",
        help="mock profile to use (defaults to mock's default)")

# TODO: provide the actual list of choices
parser.add_argument("-t", "--tool", action="append", default=[],
        help="enable the selected tool (may be used more than once)")

parser.add_argument("-c", "--shell-cmd",
        help="use shell command to build the given tarball (instead of SRPM)")

parser.add_argument("--install", dest="list_of_pkgs",
        help="space-separated list of packages to install into the chroot")

parser.add_argument("-o", "--output",
        help="name of the tarball or directory to put the results to")

parser.add_argument("-f", "--force", action="store_true",
        help="overwrite the resulting file or directory if it exists already")

parser.add_argument("--no-clean", action="store_true",
        help="do not clean chroot when it becomes unused")

# --skip-patches and --diff-patches are mutually exclusive
group = parser.add_mutually_exclusive_group()
group.add_argument("--skip-patches", action="store_true",
        help="skip patches not annotated by %%{?_rawbuild} (vanilla build)")
group.add_argument("--diff-patches", action="store_true",
        help="scan with/without patches and diff the lists of defects")

# needed for help2man
parser.add_argument("--version", action=VersionPrinter,
        help="print the version of csmock and exit")

# parse command-line arguments
args = parser.parse_args()

# make sure that 'srpm' is a file (note it can be a tar archive instead of SRPM)
srpm = args.SRPM
require_file(parser, srpm)

# make sure that we have a configuration for the selected mock profile
mock_profile = args.mock_profile
require_file(parser, "/etc/mock/%s.cfg" % mock_profile)

# fail if a not yet implemented option is given
if args.tool != []:
    parser.error("option -t is not implemented yet")
if args.shell_cmd is not None:
    parser.error("option -c is not implemented yet")
if args.list_of_pkgs is not None:
    parser.error("option --install is not implemented yet")
if args.skip_patches:
    parser.error("option --skip-patches is not implemented yet")
if args.diff_patches:
    parser.error("option --diff-patches is not implemented yet")

# resolve name of the file/dir we are going to store the results to
output = args.output
if args.output is None:
    output = nvr_from_srpm(srpm) + ".tar.xz"
output = os.path.realpath(output)

# FIXME: TOCTOU race
if os.path.exists(output) and not args.force:
    parser.error("'%s' already exists, use --force to proceed" % output)

with ScanResults(output) as results:
    if (results.get_cmd_output("rpm -pq '%s'" % srpm)[0] != 0):
        results.fatal_error("failed to open SRPM: %s" % srpm)

    # TODO

    with MockWrapper(results, mock_profile) as mock:
        if (mock.exec_mock_cmd(["--init"]) != 0):
            results.fatal_error("failed to init mock profile: %s"
                    % mock_profile)

        # TODO

        if not args.no_clean:
            if (mock.exec_mock_cmd(["--clean"]) != 0):
                results.error("failed to clean mock profile", ec=0)

    # TODO
