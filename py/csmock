#!/usr/bin/env python

# Copyright (C) 2014 Red Hat, Inc.
#
# This file is part of csmock.
#
# csmock is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# csmock is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with csmock.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import codecs
import copy
import datetime
import imp
import os.path
import re
import signal
import socket
import shutil
import subprocess
import sys
import tempfile
import time

csmock_datadir = "/usr/share/csmock"

patch_rawbuild = csmock_datadir + "/scripts/patch-rawbuild.sh"

cwe_list_file = csmock_datadir + "/cwe-map.csv"

plugin_dir= "@PLUGIN_DIR@"

default_rpm_opts = [
        "--define",     "_smp_mflags -kj13",
        "--define",     "_without_testsuite 1",
        "--define",     "apidocs 0",
        "--define",     "libguestfs_runtests 0",
        "--define",     "runselftest 0",
        "--define",     "with_docs 0",
        "--define",     "with_publican 0",
        "--without",    "binfilter",
        "--without",    "langpacks"]

rawbuild_rpm_opts = [
        "--define",     "__patch " + patch_rawbuild,
        "--define",     "_rawbuild -b _RAWBUILD",
        "--define",     "nofips 1",
        "--define",     "nopam 1",
        "--define",     "norunuser 1",
        "--define",     "noselinux 1",
        "--define",     "_with_vanilla 1"]

default_cswrap_filters = [
        "csgrep --quiet --path '^/builddir/build/BUILD/' \
--event='error|warning' --remove-duplicates"]

# remember to use --mode=json for csgrep (TODO: improve csgrep's interface)
default_result_filters = [
        "csgrep --mode=json --strip-path-prefix /builddir/build/BUILD/",
        "csgrep --mode=json --invert-match --path 'CMakeFiles/CMakeTmp|conftest.c'"]

def current_iso_date():
    return datetime.datetime.now().isoformat()

def shell_quote(str_in):
    str_out = ""
    for i in range(0, len(str_in)):
        c = str_in[i]
        if c == "\\":
            str_out += "\\\\"
        elif c == "\"":
            str_out += "\\\""
        else:
            str_out += c
    return "\"" + str_out + "\""

class ScanResults:
    def __init__(self, output):
        self.output = output
        self.use_xz = False
        self.use_tar = False
        self.dirname = os.path.basename(output)
        self.codec = codecs.lookup('utf8')
        self.ec = 0

        m = re.match("^(.*)\\.xz$", self.dirname)
        if m is not None:
            self.use_xz = True
            self.dirname = m.group(1)

        m = re.match("^(.*)\\.tar$", self.dirname)
        if m is not None:
            self.use_tar = True
            self.dirname = m.group(1)

    def utf8_wrap(self, fd):
        # the following hack is needed to support both Python 2 and 3
        return codecs.StreamReaderWriter(fd,
                self.codec.streamreader,
                self.codec.streamwriter)

    def __enter__(self):
        self.tmpdir = tempfile.mkdtemp(prefix="csmock")
        if self.use_tar:
            self.resdir = "%s/%s" % (self.tmpdir, self.dirname)
        else:
            if os.path.exists(output):
                shutil.rmtree(output)
            self.resdir = output
        os.mkdir(self.resdir)

        self.dbgdir = "%s/debug" % self.resdir
        os.mkdir(self.dbgdir)

        self.dbgdir_raw = "%s/raw-results" % self.dbgdir
        os.mkdir(self.dbgdir_raw)

        self.dbgdir_uni = "%s/uni-results" % self.dbgdir
        os.mkdir(self.dbgdir_uni)

        tee = ["tee", "%s/scan.log" % self.resdir]
        self.log_pid = subprocess.Popen(tee, stdin=subprocess.PIPE,
                preexec_fn=os.setsid)
        self.log_fd = self.utf8_wrap(self.log_pid.stdin)

        def signal_handler(signal, frame):
            # FIXME: we should use Async-signal-safe functions only
            self.fatal_error("caught signal %d" % signal, ec=(0x80 + signal))
        for i in [signal.SIGINT, signal.SIGTERM]:
            signal.signal(i, signal_handler)

        return self

    def __exit__(self, type, value, bt):
        if hasattr(self, "p") and self.p.returncode is None:
            # FIXME: TOCTOU race
            os.kill(self.p.pid, signal.SIGTERM)
        self.print_with_ts("csmock exit code: %d\n" % self.ec, prefix=">>> ")
        self.log_fd.close()
        self.log_fd = sys.stderr
        if self.use_tar:
            tar_opts = "-c"
            if self.use_xz:
                tar_opts += "J"
            tar_cmd = "tar %s -f '%s' -C '%s' '%s'" % (tar_opts,
                    self.output, self.tmpdir, self.dirname)
            if os.system(tar_cmd) != 0:
                self.fatal_error("failed to write '%s', not removing '%s'..."
                        % (self.output, self.tmpdir))

        sys.stderr.write("Wrote: %s\n\n" % self.output)
        shutil.rmtree(self.tmpdir)
        if type is None and value is None and bt is None:
            sys.exit(self.ec)

    def print_with_ts(self, msg, prefix="<<< "):
        self.log_fd.write("%s%s\t%s\n" % (prefix, current_iso_date(), msg))
        self.log_fd.flush()

    def error(self, msg, ec=1, err_prefix=""):
        self.print_with_ts("%serror: %s\n" % (err_prefix, msg), prefix="!!! ")
        if (self.ec < ec):
            self.ec = ec

    def fatal_error(self, msg, ec=1):
        self.error(msg, err_prefix="fatal ", ec=ec)
        sys.exit(ec)

    def exec_cmd(self, cmd, shell=False):
        self.print_with_ts(str(cmd))
        self.p = subprocess.Popen(cmd, stdout=self.log_fd, stderr=self.log_fd,
                shell=shell)
        rv = self.p.wait()
        self.log_fd.write("\n")
        return rv

    def get_cmd_output(self, cmd, input=None):
        self.p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                stderr=self.log_fd, shell=True)
        (out, _) = self.p.communicate()
        out = out.decode("utf8")
        return (self.p.returncode, out)

    def open_res_file(self, rel_path):
        abs_path = "%s/%s" % (self.resdir, rel_path)
        return open(abs_path, "w")

class IniWriter:
    def __init__(self, results):
        self.results = results

    def __enter__(self):
        self.ini = self.results.open_res_file("scan.ini")
        self.write("[scan]\n")
        self.append("tool", "csmock")
        self.append("tool-version", "@VERSION@")
        self.append("tool-args", str(sys.argv))
        self.append("host", socket.gethostname())
        self.append("store-results-to", self.results.output)
        self.append("time-created", current_iso_date())
        return self

    def __exit__(self, type, value, bt):
        self.append("time-finished", current_iso_date())
        self.append("exit-code", self.results.ec)
        self.ini.close()

    def write(self, text):
        self.ini.write(text)
        results.log_fd.write("scan.ini: " + text)

    def append(self, key, value):
        self.write("%s = %s\n" % (key, value))

class MockWrapper:
    def __init__(self, results, mock_profile):
        self.results = results
        self.mock_profile = mock_profile
        self.lock_file = "/tmp/.csmock-%s.lock" % mock_profile
        self.meta_lock_file = "/tmp/.csmock-%s.metalock" % mock_profile
        self.pid = os.getpid()

    def __enter__(self):
        cmd = "flock -w15 '%s' -c \"test ! -f '%s' && echo %d > '%s'\"" % (
                self.meta_lock_file, self.lock_file, self.pid, self.lock_file)
        while (os.system(cmd) != 0):
            f = open(self.lock_file)
            other_pid = ""
            if f is not None:
                other_pid = f.readline().rstrip()
                f.close()
            msg = "waiting till %s (PID %s) disappears..."
            self.results.print_with_ts(msg % (self.lock_file, other_pid))
            time.sleep(15)

        # prepare the mock command template with default arguments
        if os.path.exists("/usr/bin/mock-unbuffered"):
            mock = "mock-unbuffered"
        else:
            mock = "mock"
        self.def_cmd = [mock, "-r", self.mock_profile]
        if (results.get_cmd_output("mock --help | grep package_state")[0] == 0):
            self.def_cmd += ["--disable-plugin=package_state"]

        return self

    def __exit__(self, type, value, bt):
        cmd = "test -r '%s' && test %d = \"$(<%s)\" && rm -f '%s'" % (
                self.lock_file, self.pid, self.lock_file, self.lock_file)
        os.system(cmd)

    def get_mock_cmd(self, args):
        return self.def_cmd + args

    def exec_mock_cmd(self, args):
        return self.results.exec_cmd(self.get_mock_cmd(args))

    def exec_chroot_cmd(self, cmd):
        return self.exec_mock_cmd(["--chroot", cmd])

    def exec_mockbuild_cmd(self, cmd):
        return self.exec_chroot_cmd("/bin/su mockbuild -lc %s"
                % shell_quote(cmd))

    def copy_out(self, src, dst):
        args = ["--disable-plugin=selinux", "--copyout", src, dst]
        return self.exec_mock_cmd(args)

class ScanProps:
    def __init__(self):
        self.install_pkgs = []
        self.copy_in_files = []
        self.rpm_opts = default_rpm_opts
        self.path = []
        self.env = { }
        self.copy_out_files = []
        self.cswrap_enabled = False
        self.cswrap_filters = default_cswrap_filters
        self.result_filters = default_result_filters

    def enable_cswrap(self):
        if self.cswrap_enabled:
            # already enabled
            return
        self.cswrap_enabled = True

        # FIXME: /usr/lib64 is arch-specific
        self.copy_in_files += ["/usr/bin/cswrap", "/usr/lib64/cswrap"]
        self.path = ["/usr/lib64/cswrap"] + props.path
        self.env["CSWRAP_CAP_FILE"] = "/builddir/cswrap-capture.err"
        self.env["CSWRAP_TIMEOUT"] = "300"
        self.copy_out_files += ["/builddir/cswrap-capture.err"]

    def pick_cswrap_results(self, results):
        if not self.cswrap_enabled:
            return

        # apply all filters using a shell pipe
        fin = "%s/cswrap-capture.err" % results.dbgdir_raw
        out = "%s/cswrap-capture.err" % results.dbgdir_uni
        cmd = "cat '%s'" % fin
        for filt in self.cswrap_filters:
            cmd += " | %s" % filt
        cmd += " > '%s'" % out
        (rv, _) = results.get_cmd_output(cmd)
        return rv

    def wrap_shell_cmd_by_env(self, cmd_in):
        # merge self.env with self.path
        merged_env = copy.deepcopy(self.env)
        path_str = ""
        for p in self.path:
            path_str += p + ":"
        path_str += "\\$PATH"
        assert "PATH" not in merged_env
        merged_env["PATH"] = path_str

        # serialize all environment variables
        cmd_out = ""
        for var in merged_env:
            cmd_out += "%s='%s' " % (var, merged_env[var])

        # run a new instance of shell for the specified command
        cmd_out += "sh -c %s" % shell_quote(cmd_in)
        return cmd_out

class PluginManager:
    def __init__(self):
        self.plug_by_prio = { }
        self.plug_by_name = { }

    def try_load(self, modname, path):
        fp, pathname, description = imp.find_module(modname, [path])
        try:
            module = imp.load_module(modname, fp, pathname, description)
            plugin = module.Plugin()
        finally:
            fp.close()

        props = plugin.get_props()
        # TODO: check API version
        prio = props.pass_priority
        assert prio not in self.plug_by_prio
        self.plug_by_prio[prio] = plugin
        self.plug_by_name[modname] = plugin

    def load_default_plugins(self):
        try:
            files = os.listdir(plugin_dir)
        except:
            return

        for fname in files:
            parts = fname.split(".")
            if len(parts) != 2:
                continue
            if parts[1] != "py":
                continue
            self.try_load(parts[0], path=plugin_dir)

    def get_name_list(self):
        return self.plug_by_name.keys()

    def enable(self, plugin_name):
        plugin = self.plug_by_name[plugin_name]
        plugin.enable()

    def handle_args(self, args, props):
        for prio in self.plug_by_prio:
            plugin = self.plug_by_prio[prio]
            plugin.handle_args(args, props)

def deplist_from_srpm(results, srpm):
    (_, deps) = results.get_cmd_output("rpm -qp '%s' --requires" % srpm)
    return filter(None, deps.split("\n"))

def strlist_to_shell_cmd(lst):
    cmd = ""
    for i in lst:
        cmd += " '%s'" % i
    return cmd

def transform_results(js_file, results):
    err_file  = re.sub("\.js", ".err",  js_file)
    html_file = re.sub("\.js", ".html", js_file)
    results.exec_cmd("csgrep '%s' > '%s'" % (js_file, err_file) , shell=True)
    results.exec_cmd("cshtml '%s' > '%s'" % (js_file, html_file), shell=True)
    return (err_file, html_file)

# argparse._VersionAction would write to stderr, which breaks help2man
class VersionPrinter(argparse.Action):
    def __init__(self, option_strings, dest=None, default=None, help=None):
        super(VersionPrinter, self).__init__(option_strings=option_strings,
                dest=dest, default=default, nargs=0, help=help)
    def __call__(self, parser, namespace, values, option_string=None):
        print("@VERSION@")
        sys.exit(0)

def require_file(parser, name):
    """Print an error and exit unsuccessfully if 'name' is not a file"""
    if not os.path.isfile(name):
        parser.error("'%s' is not a file" % name)

def nvr_from_srpm(srpm):
    return re.sub("\.src\.rpm$", "", os.path.basename(srpm))

def nvr_from_tarball(tb):
    return re.sub("\.tar$", "", re.sub("\.[^.]*$", "", os.path.basename(srpm)))

# load plug-ins
plugins = PluginManager()
plugins.load_default_plugins()
plugin_list = plugins.get_name_list()

# list available tools
# FIXME: --list-available-tools takes precedence over --help and --version
class ToolsPrinter(argparse.Action):
    def __init__(self, option_strings, dest=None, default=None, help=None):
        super(ToolsPrinter, self).__init__(option_strings=option_strings,
                dest=dest, default=default, nargs=0, help=help)
    def __call__(self, parser, namespace, values, option_string=None):
        for i in plugin_list:
            # TODO: print description?
            sys.stdout.write("%s\n" % i)
        sys.exit(0)

# initialize argument parser
parser = argparse.ArgumentParser()
parser.add_argument("SRPM",
        help="source RPM package to be scanned by static analyzers")

# define optional arguments
parser.add_argument("-r", "--root", dest="mock_profile", default="default",
        help="mock profile to use (defaults to mock's default)")

parser.add_argument("-t", "--tools", default="",
        help="comma-spearated list of tools to enable")

parser.add_argument("-l", "--list-available-tools", action=ToolsPrinter,
        help="list available tools and exit")

parser.add_argument("-c", "--shell-cmd",
        help="use shell command to build the given tarball (instead of SRPM)")

parser.add_argument("--install", dest="list_of_pkgs",
        help="space-separated list of packages to install into the chroot")

parser.add_argument("-o", "--output",
        help="name of the tarball or directory to put the results to")

parser.add_argument("-f", "--force", action="store_true",
        help="overwrite the resulting file or directory if it exists already")

parser.add_argument("--no-clean", action="store_true",
        help="do not clean chroot when it becomes unused")

# --skip-patches and --diff-patches are mutually exclusive
group = parser.add_mutually_exclusive_group()
group.add_argument("--skip-patches", action="store_true",
        help="skip patches not annotated by %%{?_rawbuild} (vanilla build)")
group.add_argument("--diff-patches", action="store_true",
        help="scan with/without patches and diff the lists of defects")

# needed for help2man
parser.add_argument("--version", action=VersionPrinter,
        help="print the version of csmock and exit")

# TODO: add command-line options handled by plugins

# parse command-line arguments
args = parser.parse_args()

# check that only available tools are requested
for i in args.tools.split(","):
    tool = i.strip()
    if len(tool) == 0:
        continue
    if tool in plugin_list:
        # explicitly enable this tool
        plugins.enable(tool)
    else:
        parser.error("tool not available: %s" % tool)

props = ScanProps()

# make sure that 'srpm' is a file (note it can be a tar archive instead of SRPM)
srpm = args.SRPM
require_file(parser, srpm)

# make sure that we have a configuration for the selected mock profile
mock_profile = args.mock_profile
require_file(parser, "/etc/mock/%s.cfg" % mock_profile)

if args.list_of_pkgs is not None:
    # append the list of packages to install specified on command-line
    props.install_pkgs += args.list_of_pkgs.split()

# fail if a not yet implemented option is given
if args.diff_patches:
    parser.error("option --diff-patches is not implemented yet")

# resolve name of the file/dir we are going to store the results to
output = args.output
if args.output is None:
    if args.shell_cmd is None:
        nvr = nvr_from_srpm(srpm)
    else:
        nvr = nvr_from_tarball(srpm)
    output = nvr + ".tar.xz"
output = os.path.realpath(output)

# FIXME: TOCTOU race
if os.path.exists(output) and not args.force:
    parser.error("'%s' already exists, use --force to proceed" % output)

if args.skip_patches:
    props.copy_in_files += [patch_rawbuild]
    props.rpm_opts += rawbuild_rpm_opts

# poll plug-ins to reflect themselves in ScanProps
plugins.handle_args(args, props)

with ScanResults(output) as results:
    # dump list of RPMs installed on the host (for debugging purposes)
    results.exec_cmd("rpm -qa | sort -V > '%s/rpm-list-host.txt'"
            % results.dbgdir, shell=True)

    with IniWriter(results) as ini_writer:
        ini_writer.append("mock-config", mock_profile)

        if args.shell_cmd is None:
            # check the given SRPM
            if (results.get_cmd_output("rpm -pq '%s'" % srpm)[0] != 0):
                results.fatal_error("failed to open SRPM: %s" % srpm)
            (ec, spec) = results.get_cmd_output("rpm -lpq '%s' | grep '\.spec$'"
                    % srpm)
            if ec != 0:
                results.fatal_error("no specfile found in SRPM: %s" % srpm)
            spec = spec.rstrip()
            spec_in = "/builddir/build/SPECS/%s" % spec

        # copy the given SRPM into our tmp dir
        srpm_dup = "%s/%s" % (results.tmpdir, os.path.basename(srpm))
        shutil.copyfile(srpm, srpm_dup)
        props.copy_in_files += [srpm_dup]

        # get the dependency list of the given SRPM
        props.install_pkgs += deplist_from_srpm(results, srpm)

        with MockWrapper(results, mock_profile) as mock:
            if (mock.exec_mock_cmd(["--init"]) != 0):
                results.fatal_error("failed to init mock profile: %s"
                        % mock_profile)

            # install required packages according to ScanProps
            mock.exec_mock_cmd(["--install"] + props.install_pkgs)

            # dump list of RPMs installed in the chroot (for debugging purposes)
            tmp_var_lib = "%s/var/lib" % results.tmpdir
            os.makedirs(tmp_var_lib)
            mock.copy_out("/var/lib/rpm", "%s/rpm" % tmp_var_lib)
            results.exec_cmd("rpm -qa | sort -V > '%s/rpm-list-mock.txt'"
                    % results.dbgdir, shell=True)

            if args.shell_cmd is not None:
                # prepare a build script in our tmp dir
                build_script = "%s/build.sh" % results.tmpdir
                results.get_cmd_output("printf '#!/bin/sh\n\
cd /builddir/build/BUILD || exit $?\n\
cd %%s*/\n\
%%s' '%s' '%s' | tee '%s' >&2\n" % (nvr_from_tarball(srpm),
                args.shell_cmd, build_script))
                props.copy_in_files += [build_script]

            # copy required files into the chroot
            cmd = "tar -cP"
            cmd += strlist_to_shell_cmd(props.copy_in_files)
            cmd += " | "
            cmd += strlist_to_shell_cmd(
                    mock.get_mock_cmd(["--shell", "tar -xC/"]))
            results.get_cmd_output(cmd)

            # TODO: run fixups

            if args.shell_cmd is None:
                # install the copied SRPM into the chroot
                mock.exec_chroot_cmd("rpm -Uvh --nodeps '%s'" % srpm_dup)

                # run %prep phase without pluggin-in any static analyzers
                ec = mock.exec_mockbuild_cmd("rpmbuild -bp --nodeps %s%s"
                        % (spec_in, strlist_to_shell_cmd(props.rpm_opts)))
            else:
                # extract the given archive (we got instead of SRPM)
                ec = mock.exec_mockbuild_cmd(
                        "tar -xvf '%s' -C /builddir/build/BUILD" % srpm_dup)

            if (ec != 0):
                results.error("%prep failed", ec=ec)

            if args.shell_cmd is None:
                # run %build phase with static analyzers plugged-in
                build_cmd = "rpmbuild -bc --nodeps --short-circuit %s%s" \
                        % (spec_in, strlist_to_shell_cmd(props.rpm_opts))
            else:
                # run the above prepared build script
                build_cmd = "sh -x '%s'" % build_script

            # TODO: wrap build_cmd by all the necessary wrappers

            # initialize environment variables according to ScanProps
            build_cmd = props.wrap_shell_cmd_by_env(build_cmd)

            ec = mock.exec_mockbuild_cmd(build_cmd)
            if (ec != 0):
                results.error("%build failed", ec=ec)

            # get the (intermediate) results out of the chroot
            copy_out_cmd = ["--disable-plugin=selinux", "--copyout"]
            copy_out_cmd += props.copy_out_files + [results.dbgdir_raw]
            if mock.exec_mock_cmd(copy_out_cmd) != 0:
                results.error("mock --copyout field")

            # TODO

            if not args.no_clean:
                if (mock.exec_mock_cmd(["--clean"]) != 0):
                    results.error("failed to clean mock profile", ec=0)

        # we are done with mock

        if props.pick_cswrap_results(results) != 0:
            results.error("failed to pick cswrap results")

        # TODO

    # we are done with IniWriter

    # merge all results into a single file named scan-results.js
    ini_file = "%s/scan.ini" % results.resdir
    js_file = "%s/scan-results.js" % results.resdir
    cmd = "cslinker --cwelist '%s' --inifile '%s' %s/*.err" % (cwe_list_file,
            ini_file, results.dbgdir_uni)
    for filt in props.result_filters:
        cmd += " | %s" % filt
    cmd += " > '%s'" % js_file
    results.exec_cmd(cmd, shell=True)

    # transform scan-results.js to scan-results.{err,html} and print stats
    (err_file, _) = transform_results(js_file, results)
    results.exec_cmd(["csgrep", "--mode=stat", err_file])
