#!/usr/bin/env python

# Copyright (C) 2014 Red Hat, Inc.
#
# This file is part of csmock.
#
# csmock is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# csmock is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with csmock.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import codecs
import datetime
import os.path
import re
import signal
import socket
import shutil
import subprocess
import sys
import tempfile
import time

def current_iso_date():
    return datetime.datetime.now().isoformat()

def shell_quote(str_in):
    str_out = ""
    for i in range(0, len(str_in)):
        c = str_in[i]
        if c == "\\":
            str_out += "\\\\"
        elif c == "\"":
            str_out += "\\\""
        else:
            str_out += c
    return "\"" + str_out + "\""

class ScanResults:
    def __init__(self, output):
        self.output = output
        self.use_xz = False
        self.use_tar = False
        self.dirname = os.path.basename(output)
        self.codec = codecs.lookup('utf8')
        self.ec = 0

        m = re.match("^(.*)\\.xz$", self.dirname)
        if m is not None:
            self.use_xz = True
            self.dirname = m.group(1)

        m = re.match("^(.*)\\.tar$", self.dirname)
        if m is not None:
            self.use_tar = True
            self.dirname = m.group(1)

    def utf8_wrap(self, fd):
        # the following hack is needed to support both Python 2 and 3
        return codecs.StreamReaderWriter(fd,
                self.codec.streamreader,
                self.codec.streamwriter)

    def __enter__(self):
        self.tmpdir = tempfile.mkdtemp(prefix="csmock")
        if self.use_tar:
            self.resdir = "%s/%s" % (self.tmpdir, self.dirname)
        else:
            if os.path.exists(output):
                shutil.rmtree(output)
            self.resdir = output
        os.mkdir(self.resdir)

        self.dbgdir = "%s/debug" % self.resdir
        os.mkdir(self.dbgdir)

        tee = ["tee", "%s/scan.log" % self.resdir]
        self.log_pid = subprocess.Popen(tee, stdin=subprocess.PIPE,
                preexec_fn=os.setsid)
        self.log_fd = self.utf8_wrap(self.log_pid.stdin)

        def signal_handler(signal, frame):
            # FIXME: we should use Async-signal-safe functions only
            self.fatal_error("caught signal %d" % signal, ec=(0x80 + signal))
        for i in [signal.SIGINT, signal.SIGTERM]:
            signal.signal(i, signal_handler)

        return self

    def __exit__(self, type, value, bt):
        if hasattr(self, "p") and self.p.returncode is None:
            # FIXME: TOCTOU race
            os.kill(self.p.pid, signal.SIGTERM)
        self.print_with_ts("csmock exit code: %d\n" % self.ec, prefix=">>> ")
        self.log_fd.close()
        self.log_fd = sys.stderr
        if self.use_tar:
            tar_opts = "-c"
            if self.use_xz:
                tar_opts += "J"
            tar_cmd = "tar %s -f '%s' -C '%s' '%s'" % (tar_opts,
                    self.output, self.tmpdir, self.dirname)
            if os.system(tar_cmd) != 0:
                self.fatal_error("failed to write '%s', not removing '%s'..."
                        % (self.output, self.tmpdir))

        sys.stderr.write("Wrote: %s\n\n" % self.output)
        shutil.rmtree(self.tmpdir)
        if type is None and value is None and bt is None:
            sys.exit(self.ec)

    def print_with_ts(self, msg, prefix="<<< "):
        self.log_fd.write("%s%s\t%s\n" % (prefix, current_iso_date(), msg))
        self.log_fd.flush()

    def error(self, msg, ec=1, err_prefix=""):
        self.print_with_ts("%serror: %s\n" % (err_prefix, msg), prefix="!!! ")
        if (self.ec < ec):
            self.ec = ec

    def fatal_error(self, msg, ec=1):
        self.error(msg, err_prefix="fatal ", ec=ec)
        sys.exit(ec)

    def exec_cmd(self, cmd, shell=False):
        self.print_with_ts(str(cmd))
        self.p = subprocess.Popen(cmd, stdout=self.log_fd, stderr=self.log_fd,
                shell=shell)
        rv = self.p.wait()
        self.log_fd.write("\n")
        return rv

    def get_cmd_output(self, cmd, input=None):
        self.p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                stderr=self.log_fd, shell=True)
        (out, _) = self.p.communicate()
        return (self.p.returncode, out)

    def open_res_file(self, rel_path):
        abs_path = "%s/%s" % (self.resdir, rel_path)
        return open(abs_path, "w")

class IniWriter:
    def __init__(self, results):
        self.results = results

    def __enter__(self):
        self.ini = self.results.open_res_file("scan.ini")
        self.write("[scan]\n")
        self.append("tool", "csmock")
        self.append("tool-version", "@VERSION@")
        self.append("tool-args", str(sys.argv))
        self.append("host", socket.gethostname())
        self.append("store-results-to", self.results.output)
        self.append("time-created", current_iso_date())
        return self

    def __exit__(self, type, value, bt):
        self.append("time-finished", current_iso_date())
        self.append("exit-code", self.results.ec)
        self.ini.close()

    def write(self, text):
        self.ini.write(text)
        results.log_fd.write("scan.ini: " + text)

    def append(self, key, value):
        self.write("%s = %s\n" % (key, value))

class MockWrapper:
    def __init__(self, results, mock_profile):
        self.results = results
        self.mock_profile = mock_profile
        self.lock_file = "/tmp/.csmock-%s.lock" % mock_profile
        self.meta_lock_file = "/tmp/.csmock-%s.metalock" % mock_profile
        self.pid = os.getpid()

    def __enter__(self):
        cmd = "flock -w15 '%s' -c \"test ! -f '%s' && echo %d > '%s'\"" % (
                self.meta_lock_file, self.lock_file, self.pid, self.lock_file)
        while (os.system(cmd) != 0):
            f = open(self.lock_file)
            other_pid = ""
            if f is not None:
                other_pid = f.readline().rstrip()
                f.close()
            msg = "waiting till %s (PID %s) disappears..."
            self.results.print_with_ts(msg % (self.lock_file, other_pid))
            time.sleep(15)

        # prepare the mock command template with default arguments
        if os.path.exists("/usr/bin/mock-unbuffered"):
            mock = "mock-unbuffered"
        else:
            mock = "mock"
        self.def_cmd = [mock, "-r", self.mock_profile]
        if (results.get_cmd_output("mock --help | grep package_state")[0] == 0):
            self.def_cmd += ["--disable-plugin=package_state"]

        return self

    def __exit__(self, type, value, bt):
        cmd = "test -r '%s' && test %d = \"$(<%s)\" && rm -f '%s'" % (
                self.lock_file, self.pid, self.lock_file, self.lock_file)
        os.system(cmd)

    def get_mock_cmd(self, args):
        return self.def_cmd + args

    def exec_mock_cmd(self, args):
        return self.results.exec_cmd(self.get_mock_cmd(args))

    def exec_chroot_cmd(self, cmd):
        return self.exec_mock_cmd(["--chroot", cmd])

    def exec_mockbuild_cmd(self, cmd):
        return self.exec_chroot_cmd("/bin/su mockbuild -lc %s"
                % shell_quote(cmd))

    def copy_out(self, src, dst):
        args = ["--disable-plugin=selinux", "--copyout", src, dst]
        return self.exec_mock_cmd(args)

class ScanProps:
    def __init__(self):
        self.install_pkgs = []
        self.copy_in_files = []

def deplist_from_srpm(results, srpm):
    (_, deps) = results.get_cmd_output("rpm -qp '%s' --requires" % srpm)
    return filter(None, deps.split("\n"))

def strlist_to_shell_cmd(lst):
    cmd = ""
    for i in lst:
        cmd += " '%s'" % i
    return cmd

# argparse._VersionAction would write to stderr, which breaks help2man
class VersionPrinter(argparse.Action):
    def __init__(self, option_strings, dest=None, default=None, help=None):
        super(VersionPrinter, self).__init__(option_strings=option_strings,
                dest=dest, default=default, nargs=0, help=help)
    def __call__(self, parser, namespace, values, option_string=None):
        print("@VERSION@")
        sys.exit(0)

def require_file(parser, name):
    """Print an error and exit unsuccessfully if 'name' is not a file"""
    if not os.path.isfile(name):
        parser.error("'%s' is not a file" % name)

def nvr_from_srpm(srpm):
    return re.sub('\.src\.rpm$', '', os.path.basename(srpm))

# initialize argument parser
parser = argparse.ArgumentParser()
parser.add_argument("SRPM",
        help="source RPM package to be scanned by static analyzers")

# TODO: register plug-ins

# define optional arguments
parser.add_argument("-r", "--root", dest="mock_profile", default="default",
        help="mock profile to use (defaults to mock's default)")

# TODO: provide the actual list of choices
parser.add_argument("-t", "--tool", action="append", default=[],
        help="enable the selected tool (may be used more than once)")

parser.add_argument("-c", "--shell-cmd",
        help="use shell command to build the given tarball (instead of SRPM)")

parser.add_argument("--install", dest="list_of_pkgs",
        help="space-separated list of packages to install into the chroot")

parser.add_argument("-o", "--output",
        help="name of the tarball or directory to put the results to")

parser.add_argument("-f", "--force", action="store_true",
        help="overwrite the resulting file or directory if it exists already")

parser.add_argument("--no-clean", action="store_true",
        help="do not clean chroot when it becomes unused")

# --skip-patches and --diff-patches are mutually exclusive
group = parser.add_mutually_exclusive_group()
group.add_argument("--skip-patches", action="store_true",
        help="skip patches not annotated by %%{?_rawbuild} (vanilla build)")
group.add_argument("--diff-patches", action="store_true",
        help="scan with/without patches and diff the lists of defects")

# needed for help2man
parser.add_argument("--version", action=VersionPrinter,
        help="print the version of csmock and exit")

# parse command-line arguments
args = parser.parse_args()

props = ScanProps()

# make sure that 'srpm' is a file (note it can be a tar archive instead of SRPM)
srpm = args.SRPM
require_file(parser, srpm)

# make sure that we have a configuration for the selected mock profile
mock_profile = args.mock_profile
require_file(parser, "/etc/mock/%s.cfg" % mock_profile)

# fail if a not yet implemented option is given
if args.tool != []:
    parser.error("option -t is not implemented yet")
if args.shell_cmd is not None:
    parser.error("option -c is not implemented yet")
if args.list_of_pkgs is not None:
    parser.error("option --install is not implemented yet")
if args.skip_patches:
    parser.error("option --skip-patches is not implemented yet")
if args.diff_patches:
    parser.error("option --diff-patches is not implemented yet")

# resolve name of the file/dir we are going to store the results to
output = args.output
if args.output is None:
    output = nvr_from_srpm(srpm) + ".tar.xz"
output = os.path.realpath(output)

# FIXME: TOCTOU race
if os.path.exists(output) and not args.force:
    parser.error("'%s' already exists, use --force to proceed" % output)

with ScanResults(output) as results:
    # dump list of RPMs installed on the host (for debugging purposes)
    results.exec_cmd("rpm -qa | sort -V > '%s/rpm-list-host.txt'"
            % results.dbgdir, shell=True)

    with IniWriter(results) as ini_writer:
        ini_writer.append("mock-config", mock_profile)

        # check the given SRPM
        if (results.get_cmd_output("rpm -pq '%s'" % srpm)[0] != 0):
            results.fatal_error("failed to open SRPM: %s" % srpm)
        (ec, spec) = results.get_cmd_output("rpm -lpq '%s' | grep '\.spec$'"
                % srpm)
        if ec != 0:
            results.fatal_error("no specfile found in SRPM: %s" % srpm)
        spec = spec.rstrip()
        spec_in = "/builddir/build/SPECS/%s" % spec

        # copy the given SRPM into our tmp dir
        srpm_dup = "%s/%s" % (results.tmpdir, os.path.basename(srpm))
        shutil.copyfile(srpm, srpm_dup)
        props.copy_in_files += [srpm_dup]

        # get the dependency list of the given SRPM
        props.install_pkgs += deplist_from_srpm(results, srpm)

        with MockWrapper(results, mock_profile) as mock:
            if (mock.exec_mock_cmd(["--init"]) != 0):
                results.fatal_error("failed to init mock profile: %s"
                        % mock_profile)

            # install required packages according to ScanProps
            mock.exec_mock_cmd(["--install"] + props.install_pkgs)

            # dump list of RPMs installed in the chroot (for debugging purposes)
            tmp_var_lib = "%s/var/lib" % results.tmpdir
            os.makedirs(tmp_var_lib)
            mock.copy_out("/var/lib/rpm", "%s/rpm" % tmp_var_lib)
            results.exec_cmd("rpm -qa | sort -V > '%s/rpm-list-mock.txt'"
                    % results.dbgdir, shell=True)

            # copy required files into the chroot
            cmd = "tar -cP"
            cmd += strlist_to_shell_cmd(props.copy_in_files)
            cmd += " | "
            cmd += strlist_to_shell_cmd(
                    mock.get_mock_cmd(["--shell", "tar -xC/"]))
            results.get_cmd_output(cmd)

            # TODO: run fixups

            # install the copied SRPM into the chroot
            mock.exec_chroot_cmd("rpm -Uvh --nodeps '%s'" % srpm_dup)

            # run %prep phase without pluggin-in any static analyzers
            mock.exec_mockbuild_cmd("rpmbuild -bp --nodeps %s" % spec_in)

            # TODO

            if not args.no_clean:
                if (mock.exec_mock_cmd(["--clean"]) != 0):
                    results.error("failed to clean mock profile", ec=0)

        # TODO
