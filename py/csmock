#!/usr/bin/env python

# Copyright (C) 2014 Red Hat, Inc.
#
# This file is part of csmock.
#
# csmock is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# csmock is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with csmock.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import os.path
import re
import shutil
import sys
import tempfile

class ScanResults:
    def __init__(self, output):
        self.output = output
        self.use_xz = False
        self.use_tar = False
        self.dirname = os.path.basename(output)

        m = re.match("^(.*)\\.xz$", self.dirname)
        if m is not None:
            self.use_xz = True
            self.dirname = m.group(1)

        m = re.match("^(.*)\\.tar$", self.dirname)
        if m is not None:
            self.use_tar = True
            self.dirname = m.group(1)

    def __enter__(self):
        self.tmpdir = tempfile.mkdtemp(prefix="csmock")
        self.resdir = "%s/%s" % (self.tmpdir, self.dirname)
        os.mkdir(self.resdir)

    def __exit__(self, type, value, bt):
        if self.use_tar:
            tar_opts = "-c"
            if self.use_xz:
                tar_opts += "J"
            tar_cmd = "tar %s -f '%s' -C '%s' '%s'" % (tar_opts,
                    self.output, self.tmpdir, self.dirname)
            if os.system(tar_cmd) == 0:
                sys.stderr.write("Wrote: %s\n" % self.output)
                shutil.rmtree(self.tmpdir)
        else:
            os.system("mv -fvT '%s' '%s'" % (self.resdir, self.output))

# argparse._VersionAction would write to stderr, which breaks help2man
class VersionPrinter(argparse.Action):
    def __init__(self, option_strings, dest=None, default=None, help=None):
        super(VersionPrinter, self).__init__(option_strings=option_strings,
                dest=dest, default=default, nargs=0, help=help)
    def __call__(self, parser, namespace, values, option_string=None):
        print("@VERSION@")
        sys.exit(0)

def require_file(parser, name):
    """Print an error and exit unsuccessfully if 'name' is not a file"""
    if not os.path.isfile(name):
        parser.error("'%s' is not a file" % name)

def nvr_from_srpm(srpm):
    return re.sub('\.src\.rpm$', '', os.path.basename(srpm))

# initialize argument parser
parser = argparse.ArgumentParser()
parser.add_argument("SRPM",
        help="source RPM package to be scanned by static analyzers")

# TODO: register plug-ins

# define optional arguments
parser.add_argument("-r", "--root", dest="mock_profile", default="default",
        help="mock profile to use (defaults to mock's default)")

# TODO: provide the actual list of choices
parser.add_argument("-t", "--tool", action="append", default=[],
        help="enable the selected tool (may be used more than once)")

parser.add_argument("-c", "--shell-cmd",
        help="use shell command to build the given tarball (instead of SRPM)")

parser.add_argument("--install", dest="list_of_pkgs",
        help="space-separated list of packages to install into the chroot")

parser.add_argument("-o", "--output",
        help="name of the tarball or directory to put the results to")

parser.add_argument("-f", "--force", action="store_true",
        help="overwrite the resulting file or directory if it exists already")

parser.add_argument("--no-clean", action="store_true",
        help="do not clean chroot when it becomes unused")

# --skip-patches and --diff-patches are mutually exclusive
group = parser.add_mutually_exclusive_group()
group.add_argument("--skip-patches", action="store_true",
        help="skip patches not annotated by %%{?_rawbuild} (vanilla build)")
group.add_argument("--diff-patches", action="store_true",
        help="scan with/without patches and diff the lists of defects")

# needed for help2man
parser.add_argument("--version", action=VersionPrinter,
        help="print the version of csmock and exit")

# parse command-line arguments
args = parser.parse_args()

# make sure that 'srpm' is a file (note it can be a tar archive instead of SRPM)
srpm = args.SRPM
require_file(parser, srpm)

# make sure that we have a configuration for the selected mock profile
mock_profile = args.mock_profile
require_file(parser, "/etc/mock/%s.cfg" % mock_profile)

# fail if a not yet implemented option is given
if args.tool != []:
    parser.error("option -t is not implemented yet")
if args.shell_cmd is not None:
    parser.error("option -c is not implemented yet")
if args.list_of_pkgs is not None:
    parser.error("option --install is not implemented yet")
if args.no_clean:
    parser.error("option --no-clean is not implemented yet")
if args.skip_patches:
    parser.error("option --skip-patches is not implemented yet")
if args.diff_patches:
    parser.error("option --diff-patches is not implemented yet")

# resolve name of the file/dir we are going to store the results to
output = args.output
if args.output is None:
    output = nvr_from_srpm(srpm) + ".tar.xz"
output = os.path.realpath(output)

# FIXME: TOCTOU race
if os.path.exists(output) and not args.force:
    parser.error("'%s' already exists, use --force to proceed" % output)

with ScanResults(output) as results:
    # TODO
    pass
